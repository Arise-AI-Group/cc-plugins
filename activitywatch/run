#!/bin/bash
# Activate virtual environment and run Python script
# Handles venv portability issues (broken shebangs after copy/move)

set -e

# Resolve symlinks to get the actual script location
SCRIPT_PATH="$0"
if [ -L "$SCRIPT_PATH" ]; then
    SCRIPT_PATH="$(cd "$(dirname "$0")" && readlink "$SCRIPT_PATH")"
    SCRIPT_PATH="$(cd "$(dirname "$0")" && cd "$(dirname "$SCRIPT_PATH")" && pwd)/$(basename "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

VENV_DIR="$SCRIPT_DIR/.venv"
VENV_PYTHON="$VENV_DIR/bin/python3"
REQUIREMENTS="$SCRIPT_DIR/requirements.txt"

# Function to check if venv is functional
venv_is_functional() {
    [ -x "$VENV_PYTHON" ] && "$VENV_PYTHON" -c "import pip" 2>/dev/null
}

# Function to check if dependencies are installed (check common dep + marker)
deps_installed() {
    [ -f "$VENV_DIR/.deps_installed" ] && "$VENV_PYTHON" -c "import dotenv" 2>/dev/null
}

# Create or recreate venv if needed
if ! venv_is_functional; then
    echo "Setting up virtual environment..." >&2
    rm -rf "$VENV_DIR"
    python3 -m venv "$VENV_DIR"
fi

# Install dependencies if missing
if ! deps_installed; then
    echo "Installing dependencies..." >&2
    "$VENV_PYTHON" -m pip install -q -r "$REQUIREMENTS"
    touch "$VENV_DIR/.deps_installed"
fi

cd "$SCRIPT_DIR"

# Convert path like tool/script.py to module: tool.script
if [[ "$1" == *.py ]]; then
    module="${1%.py}"
    module="${module//\//.}"
    shift
    "$VENV_PYTHON" -m "$module" "$@"
else
    "$VENV_PYTHON" "$@"
fi
